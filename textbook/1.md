# 第1章 はじめに

本書では、自作言語によるソースコードを実行可能なコードへと翻訳するために

- 技法
- データ構造
- アルゴリズム

について学ぶ。

現在のコンパイラは、複数のフェーズに分けて構成されている。  
そして、それぞれが異なる抽象「言語」に対して動作する。

本書では、1つの章がコンパイラの1つのフェーズに言及するようになっている。

現実のプログラミング言語をコンパイルするときの問題を明らかにするために、  
Algol 系言語である Tiger のソースコードをどのようにコンパイルするかを示すことにした。  

Tiger には、入れ子になった有効範囲と、ヒープに割り付けられるレコードがある。

各章にある課題では、対応するフェーズの実装が求められる。

本書の第1部に記述されているすべてのフェーズを実装することによって、  
実際に動作するコンパイラを手にすることができる。

Tiger は、関数型あるいはオブジェクト指向言語に(またはその両方に)容易に変更できる。  
それをどのようにすればよいかは、第2部の演習問題に示してある。  
第2部では、プログラムの最適化に関する高度な技法について説明する章も設けてある。

付録Aに、Tiger言語についての記述がある。

コンパイラのモジュール感のインターフェースは、モジュール内のアルゴリズムと同じくらい重要である。  
インターフェースを具体的に述べるためには、それらを実際のプログラミング言語で記述するのが有益である。

関数型プログラミング言語 ML はコンパイラ実装に適している。

コンパイラ入門には、 ML のような現代的なプログラミング言語設計についての知識も含めるべきであると考える。

ただし、 ML によるプログラミングの教科書ではないので注意が必要。

## 1.1 モジュールとインターフェース

抽象とインターフェースに配慮すれば、大規模なソフトウェアシステムも容易に理解することができる。

(ソースプログラム) → 字句解析 → (トークン) → 構文解析 → (還元) → 構文解析動作 → (抽象構文) → 意味解析 → (翻訳) → 翻訳 → (IR木) → 正準化 → (IR木) → 命令選択 → (Assem) → 制御フロー解析 → (フローグラフ) → データフロー解析 → (インタフェースグラフ) → レジスタ割付け → (レジスタ割当て) → コード出力 → (アセンブリ言語) → アセンブラ → (再配置可能オブジェクトコード) → リンカ → (機械語)

正しい抽象に至るまでの思考ー実装ー再設計の数回にわたる繰り返しによる学習経験といったものはきわめて重要で、決して軽んじてはならない。
しかしながら、1学期の間でコンパイラプロジェクトを完成させなければならないとするならば、そのような悠長なことは言ってられないだろう。
そこで本書では、抽象とインターフェースについて可能な限りエレガントで一般的になるようによく検討した上で、プロジェクトのアウトラインを示すことにした。

### フェーズの記述

## 1.2 ツールとソフトウェア

## 1.3 木言語のデータ構造
