# 第1章 はじめに

本書では、自作言語によるソースコードを実行可能なコードへと翻訳するために  
「技法」「データ構造」「アルゴリズム」について学ぶ。

現在のコンパイラは、複数のフェーズに分けて構成されている。  
そして、それぞれが異なる抽象「言語」に対して動作する。

本書では、1つの章がコンパイラの1つのフェーズに言及するようになっている。

現実のプログラミング言語をコンパイルするときの問題を明らかにするために、  
Algol 系言語である Tiger のソースコードをどのようにコンパイルするかを示すことにした。  

Tiger には、入れ子になった有効範囲と、ヒープに割り付けられるレコードがある。

各章にある課題では、対応するフェーズの実装が求められる。

本書の第1部に記述されているすべてのフェーズを実装することによって、  
実際に動作するコンパイラを手にすることができる。

Tiger は、関数型あるいはオブジェクト指向言語に(またはその両方に)容易に変更できる。  
それをどのようにすればよいかは、第2部の演習問題に示してある。  
第2部では、プログラムの最適化に関する高度な技法について説明する章も設けてある。

付録Aに、Tiger言語についての記述がある。

コンパイラのモジュール感のインターフェースは、モジュール内のアルゴリズムと同じくらい重要である。  
インターフェースを具体的に述べるためには、それらを実際のプログラミング言語で記述するのが有益である。

関数型プログラミング言語 ML はコンパイラ実装に適している。

コンパイラ入門には、 ML のような現代的なプログラミング言語設計についての知識も含めるべきであると考える。

ただし、 ML によるプログラミングの教科書ではないので注意が必要。

## 1.1 モジュールとインターフェース

抽象とインターフェースに配慮すれば、大規模なソフトウェアシステムも容易に理解することができる。

(ソースプログラム) → **字句解析** → (トークン) → **構文解析** → (還元) → **構文解析動作** → (抽象構文) → **意味解析** → (翻訳) → **翻訳** → (IR木) → **正準化** → (IR木) → **命令選択** → (Assem) → **制御フロー解析** → (フローグラフ) → **データフロー解析** → (インタフェースグラフ) → **レジスタ割付け** → (レジスタ割当て) → **コード出力** → (アセンブリ言語) → **アセンブラ** → (再配置可能オブジェクトコード) → **リンカ** → (機械語)

↑ (…) : インターフェース , **太字** : 抽象

「正しい抽象に至るまでの『思考ー実装ー再設計』の数回にわたる繰り返しによる学習経験」は大事だが時間がないので、抽象とインターフェースについて簡潔に概要を示す。

### フェーズの記述

第1部の各章では、下に示すように、それぞれのフェーズについて説明している。

| 章 | フェーズ | 内容 |
| -- | -- | -- |
| 2 | 字句解析 | ソースファイルを、複数のトークンに分解する |
| 3 | 構文解析 | プログラムの句構造を解析する |
| 4 | 意味動作 | 各句に対応する抽象構文木を構築する |
| 5 | 意味解析 | 変数の使用をその定義に関連付け、<br>式の型を検査して各句の意味を決定した上で、各句の翻訳を要求する |

## 1.2 ツールとソフトウェア

## 1.3 木言語のデータ構造
