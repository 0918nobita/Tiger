# 第1章 はじめに

本書では、自作言語によるソースコードを実行可能なコードへと翻訳するために  
「技法」「データ構造」「アルゴリズム」について学ぶ。

現在のコンパイラは、複数のフェーズに分けて構成されている。  
そして、それぞれが異なる抽象「言語」に対して動作する。

本書では、1つの章がコンパイラの1つのフェーズに言及するようになっている。

現実のプログラミング言語をコンパイルするときの問題を明らかにするために、  
Algol 系言語である Tiger のソースコードをどのようにコンパイルするかを示すことにした。  

Tiger には、入れ子になった有効範囲と、ヒープに割り付けられるレコードがある。

各章にある課題では、対応するフェーズの実装が求められる。

本書の第1部に記述されているすべてのフェーズを実装することによって、  
実際に動作するコンパイラを手にすることができる。

Tiger は、関数型あるいはオブジェクト指向言語に(またはその両方に)容易に変更できる。  
それをどのようにすればよいかは、第2部の演習問題に示してある。  
第2部では、プログラムの最適化に関する高度な技法について説明する章も設けてある。

付録Aに、Tiger言語についての記述がある。

コンパイラのモジュール感のインターフェースは、モジュール内のアルゴリズムと同じくらい重要である。  
インターフェースを具体的に述べるためには、それらを実際のプログラミング言語で記述するのが有益である。

関数型プログラミング言語 ML はコンパイラ実装に適している。

コンパイラ入門には、 ML のような現代的なプログラミング言語設計についての知識も含めるべきであると考える。

ただし、 ML によるプログラミングの教科書ではないので注意が必要。

## 1.1 モジュールとインターフェース

抽象とインターフェースに配慮すれば、大規模なソフトウェアシステムも容易に理解することができる。

(ソースプログラム) → **字句解析** → (トークン) → **構文解析** → (還元) → **構文解析動作** → (抽象構文) → **意味解析** → (翻訳) → **翻訳** → (IR木) → **正準化** → (IR木) → **命令選択** → (Assem) → **制御フロー解析** → (フローグラフ) → **データフロー解析** → (インタフェースグラフ) → **レジスタ割付け** → (レジスタ割当て) → **コード出力** → (アセンブリ言語) → **アセンブラ** → (再配置可能オブジェクトコード) → **リンカ** → (機械語)

↑ (…) : インターフェース , **太字** : 抽象

「正しい抽象に至るまでの『思考ー実装ー再設計』の数回にわたる繰り返しによる学習経験」は大事だが時間がないので、抽象とインターフェースについて簡潔に概要を示す。

### フェーズの記述

第1部の各章では、下に示すように、それぞれのフェーズについて説明している。

| 章 | フェーズ | 内容 |
| -- | -- | -- |
| 2 | 字句解析 | ソースファイルを、複数のトークンに分解する |
| 3 | 構文解析 | プログラムの句構造を解析する |
| 4 | 意味動作 | 各句に対応する抽象構文木を構築する |
| 5 | 意味解析 | 変数の使用箇所と定義箇所を関連付け、<br>式の型を検査して各句の意味を決定した上で、各句の翻訳を要求する |
| 6 | フレーム割付け | 変数や関数のパラメータ等を、<br>マシン依存の形式で駆動レコード(スタックフレーム)へと配置する。 |
| 7 | 翻訳 | 特定のプログラミング言語や目的マシンのアーキテクチャに<br>束縛されない中間表現木を生成する。 |
| 8 | 正準化 | 次フェーズへの準備として、式の副作用を取り出して条件分岐を整理する。 |
| 9 | 命令選択 | IR 木の節点を、目的マシンの命令の動作に対応するようにグループ化する。 |
| 10 | 制御フロー解析 | 命令の並びを解析して、実行時にプログラムが辿る可能性のある<br>制御の流れを示す制御フローグラフを生成する。 |
| 10 | データフロー解析 | プログラムの変数を通る情報の流れに関する情報を収集する。<br>例えば生存解析は、各プログラム変数が必要とされる値を持っている箇所を計算する。 |
| 11 | レジスタ割付け | 変数やプログラムが使用する一時的な値を保持するレジスタを選択する。<br>同時に生きていない変数には、同じレジスタを使用する。 |
| 12 | コード生成 | 各マシン命令中の一時的な名前をマシンレジスタで置き換える。 |

## 1.2 ツールとソフトウェア

**文脈自由文法** と **正規表現** が、現代のコンパイラでは抽象としてよく用いられる。  
これらを最も有効に活用するには、**Lex** と **Yacc** を用いるとよい。  

| 名称 | 利用方法 |
| --- | --- |
| Lex | 宣言的な仕様を字句解析プログラムへと変換する |
| Yacc | 文法を構文解析プログラムへと変換する |

本書では、この2つを Standard ML で利用できるようにした **ML-Lex** , **ML-Yacc** を用いることにする。

## 1.3 木言語のデータ構造

コンパイラでは、データ構造の中でも中間表現をよく用いる。  
そしてその中間表現は、複数の節点型をもつ「木」の形式をとることが多い。  
節点型は、それぞれ異なる属性を持つ。  
このような木構造は、先ほど示した各フェーズのインターフェースの多くに現れる。

木表現は、ちょうどプログラミング言語と同じように、文法によって記述することができる。  
その概念を紹介するために、文と式はもつがループや if 文はもたない単純なプログラミング言語を示すことにする。

この言語の構文を以下に示す。

```
Stm → Stm ; Stm  (CompoundStm)
Stm → id := Exp  (AssignStm)
Stm → print ( ExpList )  (PrintStm)
Exp → id  (IdExp)
Exp → num (NumExp)
Exp → Exp Binop Exp  (OpExp)
Exp → ( Stm, Exp )  (EseqExp)
ExpList → Exp , ExpList  (PairExpList)
ExpList → Exp  (LastExpList)
Binop → +  (Plus)
Binop → -  (Minus)
Binop → *  (Times)
Binop → /  (Div)
```

たとえば次のプログラム

```
a := 5 + 3; b = (print(a, a - 1), 10 * a); print(b)
```

を実行すると、出力は以下のようになる。

```
8 7
80
```

このプログラムを木表現に変換すると
