(*
  第1部 コンパイラ基礎編
    第1章 はじめに
      1.1 モジュールとインターフェース
      - 構成要素を再利用できるように、コンパイラを多くの部分に分割する
      - 正しい抽象に至るまでの「思考ー実装ー再設計」の繰り返しによる学習経験が重要
      1.2 ツールとソフトウェア
      1.3 木構造のデータ構造
    第2章 字句解析 ( ソースファイルを、個々の単語あるいはトークンへと分解する )
    第3章 構文解析 ( プログラムの句構造を解析する )
    第4章 意味動作 ( 各句に対応する抽象構文木を構築する )
    第5章 意味解析 ( 変数の使用をその定義に関連づけ、式の型を検査して各句の意味を決定した上で、各句の翻訳を要求する )
    第6章 フレーム割付け ( 変数や関数やパラメータ等を、マシン依存の形式で駆動レコードへと配置する )
    第7章 翻訳 ( 特定のプログラミング言語や目的マシンのアーキテクチャに束縛されない中間表現木を生成する )
    第8章 正準化 ( 次フェーズへの準備として、式の副作用を取り出して条件分岐を整理する )
    第9章 命令選択 ( IR木の節点を、目的マシンの命令の動作に対応するようにグループ化する )
    第10章 制御フロー解析 ( 命令の並びを解析して、実行時にプログラムが辿る可能性のある制御の流れを示す制御フローグラフを生成する )
    第11章 データフロー解析 ( プログラムの変数を通る情報の流れに関する情報を収集する。たとえば生存解析は、各プログラム変数が必要とされる値を持っている箇所を計算する )
    第12章 コード生成 ( 各マシン命令中の一時的な名前をマシンレジスタで置き換える )
*)

type id = string

datatype binop = Plus | Minus | Div

datatype stm = CompoundStm of stm * stm
             | AssignStm of id * exp
             | PrintStm of exp list
     and exp = IdExp of id
             | NumExp of int
             | OpExp of exp * binop * exp
             | EseqExp of stm * exp
